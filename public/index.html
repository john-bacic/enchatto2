<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Chat Room</title>
  <base href="/" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/styles.css" />
  <style>
    :root {
      --room-info-height: 0px;
    }

    .connection-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-left: 5px;
        vertical-align: middle;
        transition: background-color 0.3s ease;
    }

    .message-header {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .username {
        display: inline-flex;
        align-items: center;
    }
  </style>
</head>
<body>
  <!-- Host Welcome Screen -->
  <div id="start-host" class="welcome-screen" style="display: none;">
    <input type="text" id="host-name" placeholder="Enter your name (optional)" class="host-name-input" />
    <button onclick="startHosting()" class="host-button">Create New Room</button>
  </div>

  <!-- Guest Welcome Screen -->
  <div id="guest-name-prompt" class="welcome-screen" style="display: none;">
    <div class="guest-selection">
      <select id="previous-guests" class="guest-select" onchange="selectPreviousGuest()">
        <option value="">Select previous name or enter new one</option>
      </select>
    </div>
    <input type="text" id="guest-name" placeholder="Enter your name" class="guest-name-input" />
    <button onclick="joinAsGuest()" class="guest-button">Join Room</button>
  </div>

  <!-- Room Info (for Hosts) -->
  <div id="room-info" style="display: none;" class="room-info">
    <button class="accordion-button active" onclick="toggleAccordion(this)">Share Room</button>
    <div class="accordion-content show">
      <div id="qr-code">
        <div class="loading">Loading QR code...</div>
      </div>
      <div class="info">
        <div>Room Number: <strong id="room-id">Loading...</strong></div>
        <div class="url-container">
          <strong id="join-url">Loading...</strong>
          <button onclick="copyUrl()" class="copy-button" id="copy-button">Copy</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Chat Container -->
  <div id="chat-container" style="display: none;" class="chat-container">
    <div class="room-info">
      <div class="chat-header">
        <div class="language-toggles">
          <label class="toggle" for="en-toggle">
            <input type="checkbox" id="en-toggle" checked />
            <span>EN</span>
          </label>
          <label class="toggle" for="jp-toggle">
            <input type="checkbox" id="jp-toggle" checked />
            <span>JP</span>
          </label>
          <label class="toggle" for="rp-toggle">
            <input type="checkbox" id="rp-toggle" checked />
            <span>Ro</span>
          </label>
        </div>
      </div>
      <div id="welcome-message"></div>
    </div>
    <!-- <div id="welcome-message"></div> -->
    <div id="messages"></div>
    <div class="message-input-container">
      <div class="message-input">
        <textarea id="message-text" placeholder="Type your message..." autocomplete="off" rows="1"></textarea>
        <button onclick="sendMessage()" class="send-button" id="send-button">
            <svg viewBox="0 0 18 18">
                <path fill="black" d="M9 5.5L14.5 14H3z" />
            </svg>                          
        </button>
      </div>
    </div>
  </div>

  <!-- Socket.IO Library -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Initialize socket with reconnection settings
    const socket = io({
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      timeout: 10000,
      transports: ['websocket', 'polling']
    });
    
    let username = null;
    let userColor = null;
    const urlParams = new URLSearchParams(window.location.search);
    let isHost = urlParams.get('host') === 'true';
    const roomId = window.location.pathname.split('/').pop();
  
    // Load stored names from localStorage
    const storedHostName = localStorage.getItem('chatHostUsername');
    const storedGuestInfo = JSON.parse(localStorage.getItem('chatGuestInfo') || '{}');
  
    // Helper to store guest info and update the dropdown
    function storeGuestInfo(name, color) {
      const guestInfo = JSON.parse(localStorage.getItem('chatGuestInfo') || '{}');
      guestInfo[name] = { color, lastUsed: new Date().toISOString() };
      localStorage.setItem('chatGuestInfo', JSON.stringify(guestInfo));
      updateGuestSelect();
    }
  
    function getGuestInfo(name) {
      const guestInfo = JSON.parse(localStorage.getItem('chatGuestInfo') || '{}');
      return guestInfo[name];
    }
  
    function updateGuestSelect() {
      const select = document.getElementById('previous-guests');
      if (!select) return;
      const guestInfo = JSON.parse(localStorage.getItem('chatGuestInfo') || '{}');
      const guests = Object.entries(guestInfo).sort((a, b) => new Date(b[1].lastUsed) - new Date(a[1].lastUsed));
      // Remove all options except the first
      while (select.options.length > 1) { select.remove(1); }
      guests.forEach(([name, info]) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        option.style.color = info.color || '#000';
        select.appendChild(option);
      });
    }
  
    function selectPreviousGuest() {
      const select = document.getElementById('previous-guests');
      const guestNameInput = document.getElementById('guest-name');
      const selectedName = select.value;
      if (selectedName) {
        guestNameInput.value = selectedName;
        const info = getGuestInfo(selectedName);
        if (info && info.color) {
          guestNameInput.style.borderColor = info.color;
        }
      } else {
        guestNameInput.value = '';
        guestNameInput.style.borderColor = '';
      }
    }
  
    if (storedHostName) {
      const hostNameInput = document.getElementById('host-name');
      if (hostNameInput) hostNameInput.value = storedHostName;
    }
    if (!isHost) { 
      updateGuestSelect();
  
      // Prepopulate the guest name input just like the host
      const storedGuestName = localStorage.getItem('chatGuestUsername');
      if (storedGuestName) {
        const guestNameInput = document.getElementById('guest-name');
        if (guestNameInput) {
          guestNameInput.value = storedGuestName;
          const guestInfo = getGuestInfo(storedGuestName);
          if (guestInfo && guestInfo.color) {
            guestNameInput.style.borderColor = guestInfo.color;
          }
        }
      }
    }
  
    // Show/hide sections based on the URL and host flag
    if (window.location.pathname === '/' || window.location.pathname === '') {
      document.getElementById('start-host').style.display = 'flex';
      document.getElementById('room-info').style.display = 'none';
      document.getElementById('chat-container').style.display = 'none';
    } else if (!isHost) {
      document.getElementById('start-host').style.display = 'none';
      document.getElementById('guest-name-prompt').style.display = 'flex';
      document.getElementById('room-info').style.display = 'none';
      document.getElementById('chat-container').style.display = 'none';
    } else {
      document.getElementById('start-host').style.display = 'none';
      document.getElementById('guest-name-prompt').style.display = 'none';
      document.getElementById('room-info').style.display = isHost ? 'block' : 'none';
      document.getElementById('chat-container').style.display = 'flex';
      initializeRoom();
    }
  
    function toggleAccordion(button) {
      button.classList.toggle('active');
      const content = button.nextElementSibling;
      content.classList.toggle('show');
      const roomInfo = document.querySelector('.room-info');
      if (roomInfo) {
        document.documentElement.style.setProperty('--room-info-height', roomInfo.offsetHeight + 'px');
      }
    }
  
    // Update room-info height on content changes using ResizeObserver
    const observer = new ResizeObserver(entries => {
      for (let entry of entries) {
        if (entry.target.classList.contains('room-info')) {
          document.documentElement.style.setProperty('--room-info-height', entry.target.offsetHeight + 'px');
        }
      }
    });
    const roomInfoElement = document.querySelector('.room-info');
    if (roomInfoElement) { observer.observe(roomInfoElement); }
  
    // Prevent bounce scrolling on iOS (except in the messages area)
    document.addEventListener('touchmove', function(e) {
      if (e.target.closest('#messages')) return;
      e.preventDefault();
    }, { passive: false });
  
    function startHosting() {
      const storedName = localStorage.getItem('chatHostUsername');
      const hostName = document.getElementById('host-name').value.trim() || storedName || 'Host';
      localStorage.setItem('chatHostUsername', hostName);
      window.location.href = `/room?host=true&hostName=${encodeURIComponent(hostName)}`;
    }
  
    function joinAsGuest() {
      const guestName = document.getElementById('guest-name').value.trim();
      if (!guestName) {
        alert('Please enter a name');
        return;
      }
      // Save the guest name for future visits (just like the host)
      localStorage.setItem('chatGuestUsername', guestName);
      const existingInfo = getGuestInfo(guestName);
      const guestColor = existingInfo ? existingInfo.color : null;
      storeGuestInfo(guestName, guestColor);
      document.getElementById('guest-name-prompt').style.display = 'none';
      document.getElementById('chat-container').style.display = 'flex';
      initializeRoom();
    }
  
    async function initializeRoom() {
      if (roomId) {
        localStorage.setItem('chatRoomId', roomId);
        try {
          const response = await fetch(`/api/room/${roomId}?host=${isHost}`);
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to join room');
          }
          const data = await response.json();
          if (isHost) { document.getElementById('qr-code').style.display = 'block'; }
          let storedName, storedColor;
          if (isHost) {
            storedName = localStorage.getItem('chatHostUsername');
          } else {
            const guestName = document.getElementById('guest-name').value.trim();
            const guestInfo = getGuestInfo(guestName);
            storedName = guestName;
            storedColor = guestInfo ? guestInfo.color : null;
          }
          document.getElementById('room-id').textContent = roomId;
          const shareUrl = `${window.location.origin}/room/${roomId}`;
          document.getElementById('join-url').textContent = shareUrl;
          socket.emit('join-room', roomId, isHost, storedName, storedColor);
          document.querySelector('.welcome-screen').style.display = 'none';
          document.querySelector('.chat-container').style.display = 'flex';
          // Recalculate the minHeight once the chat container is visible
          minHeight = messageInput.scrollHeight;
          document.getElementById('message-text').focus();
          if (isHost) {
            const qrResponse = await fetch(`/api/room/${roomId}?host=true`);
            const qrData = await qrResponse.json();
            if (qrData.qrCode) {
              const qrCodeElement = document.getElementById('qr-code');
              qrCodeElement.innerHTML = `<img src="${qrData.qrCode}" alt="QR Code">`;
            }
          }
        } catch (error) {
          console.error('Error initializing room:', error);
          alert('Failed to join room. Please try again.');
          window.location.href = '/';
        }
      }
    }
  
    // Create a message element. (Note: Removed extra logging in romanji handling for performance.)
    function createMessageElement(msg, isOwn = false) {
      const messageElement = document.createElement('div');
      messageElement.classList.add('message');
      if (isOwn) { messageElement.classList.add('own'); }
      
      const usernameSpan = document.createElement('span');
      usernameSpan.className = 'username';
      usernameSpan.textContent = msg.username;
      usernameSpan.style.color = msg.color;
      
      // Add connection dot
      const dot = document.createElement('span');
      dot.className = 'connection-dot';
      dot.style.display = 'inline-block';
      dot.style.width = '8px';
      dot.style.height = '8px';
      dot.style.borderRadius = '50%';
      dot.style.marginLeft = '5px';
      dot.style.backgroundColor = socket.connected ? '#2ecc71' : '#95a5a6';
      usernameSpan.appendChild(dot);
      
      messageElement.appendChild(usernameSpan);
      
      const messageContent = document.createElement('div');
      messageContent.className = 'message-content';
      messageElement.appendChild(messageContent);
      
      const originalText = document.createElement('span');
      originalText.className = 'text';
      originalText.textContent = msg.message;
      if (msg.sourceLang === 'en') {
        originalText.classList.add('en-text');
        originalText.style.display = showEnCheckbox.checked ? '' : 'none';
      } else if (msg.sourceLang === 'ja') {
        originalText.classList.add('jp-text');
        originalText.style.display = showJpCheckbox.checked ? '' : 'none';
      }
      messageContent.appendChild(originalText);
      
      if (msg.translation && msg.targetLang) {
        const translationText = document.createElement('span');
        translationText.className = 'text translation-text';
        translationText.textContent = msg.translation;
        if (msg.targetLang === 'en') {
          translationText.classList.add('en-text');
          translationText.style.display = showEnCheckbox.checked ? '' : 'none';
        } else if (msg.targetLang === 'ja') {
          translationText.classList.add('jp-text');
          translationText.style.display = showJpCheckbox.checked ? '' : 'none';
        }
        messageContent.appendChild(translationText);
      }
      
      if (msg.romanji) {
        const romanjiText = document.createElement('span');
        romanjiText.className = 'text rp-text';
        romanjiText.textContent = msg.romanji;
        romanjiText.style.display = showRpCheckbox.checked ? '' : 'none';
        messageContent.appendChild(romanjiText);
      }
      
      return messageElement;
    }
  
    // Initialize language toggle elements
    const showEnCheckbox = document.getElementById('en-toggle');
    const showJpCheckbox = document.getElementById('jp-toggle');
    const showRpCheckbox = document.getElementById('rp-toggle');
  
    // Load and save toggle states
    function loadToggleStates() {
      const showEn = localStorage.getItem('showEn');
      const showJp = localStorage.getItem('showJp');
      const showRp = localStorage.getItem('showRp');
      showEnCheckbox.checked = showEn === null ? true : showEn === 'true';
      showJpCheckbox.checked = showJp === null ? true : showJp === 'true';
      showRpCheckbox.checked = showRp === null ? true : showRp === 'true';
      updateMessageVisibility();
    }
    function saveToggleStates() {
      localStorage.setItem('showEn', showEnCheckbox.checked);
      localStorage.setItem('showJp', showJpCheckbox.checked);
      localStorage.setItem('showRp', showRpCheckbox.checked);
    }
    function updateMessageVisibility() {
      const messages = document.querySelectorAll('.message');
      messages.forEach(message => {
        const enTexts = message.querySelectorAll('.en-text');
        enTexts.forEach(text => { text.style.display = showEnCheckbox.checked ? '' : 'none'; });
        const jpTexts = message.querySelectorAll('.jp-text');
        jpTexts.forEach(text => { text.style.display = showJpCheckbox.checked ? '' : 'none'; });
        const rpTexts = message.querySelectorAll('.rp-text');
        rpTexts.forEach(text => { text.style.display = showRpCheckbox.checked ? '' : 'none'; });
      });
    }
    showEnCheckbox.addEventListener('change', () => { updateMessageVisibility(); saveToggleStates(); });
    showJpCheckbox.addEventListener('change', () => { updateMessageVisibility(); saveToggleStates(); });
    showRpCheckbox.addEventListener('change', () => { updateMessageVisibility(); saveToggleStates(); });
    loadToggleStates();
  
    // Socket event handlers
    socket.on('username-assigned', (data) => {
      username = data.username;
      userColor = data.color;
      isHost = data.isHost; // Update host status
      const welcomeMessage = document.getElementById('welcome-message');
      if (welcomeMessage) {
        welcomeMessage.innerHTML = `You joined as: <span style="color: ${userColor}">${username}</span>`;
      }
      if (!isHost && username) {
        storeGuestInfo(username, userColor);
        const guestNameInput = document.getElementById('guest-name');
        if (guestNameInput) { guestNameInput.style.borderColor = userColor; }
      }
      const sendButton = document.getElementById('send-button');
      if (sendButton) { sendButton.style.background = userColor; }
    });
  
    socket.on('user-joined', (data) => {
      addMessage({
        type: 'system',
        text: `${data.username} joined the chat`,
        color: data.color
      });
    });
    socket.on('user-left', (data) => {
      addMessage({
        type: 'system',
        text: `${data.username} left the chat`,
        color: data.color
      });
    });
    socket.on('chat-message', (msg) => {
      const messagesDiv = document.getElementById('messages');
      const messageElement = createMessageElement(msg, msg.username === username);
      messagesDiv.appendChild(messageElement);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });
    socket.on('recent-messages', (messagesArr) => {
      const messagesDiv = document.getElementById('messages');
      messagesDiv.innerHTML = '';
      messagesArr.forEach(msg => {
        const messageElement = createMessageElement(msg, msg.username === username);
        messagesDiv.appendChild(messageElement);
      });
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });
  
    function addMessage(message) {
      const messagesDiv = document.getElementById('messages');
      const messageElement = document.createElement('div');
      if (message.type === 'system') {
        messageElement.className = 'message system';
        messageElement.textContent = message.text;
      } else {
        messageElement.className = `message ${message.own ? 'own' : ''}`;
        const usernameSpan = document.createElement('span');
        usernameSpan.className = 'username';
        usernameSpan.textContent = message.username;
        usernameSpan.style.color = message.color;
        const textSpan = document.createElement('span');
        textSpan.className = 'text';
        textSpan.textContent = message.text;
        messageElement.appendChild(usernameSpan);
        messageElement.appendChild(textSpan);
      }
      messagesDiv.appendChild(messageElement);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
  
    function sendMessage() {
      const messageInput = document.getElementById('message-text');
      const message = messageInput.value.trim();
      if (message && username) {
        socket.emit('chat-message', roomId, message);
        messageInput.value = '';
        messageInput.rows = 1; // Reset the textarea to 1 row after sending
        sendButton.classList.remove('visible');
      }
    }
  
    const messageInput = document.getElementById('message-text');
    // Get the computed line-height (in pixels) for the textarea.
    const computedStyle = window.getComputedStyle(messageInput);
    const lineHeight = parseFloat(computedStyle.lineHeight);
    // Change from const to let so we can update it after the chat container is visible
    let minHeight = messageInput.scrollHeight;
  
    messageInput.addEventListener('input', function () {
      // Reset rows to the minimum (1 row) before recalculating.
      this.rows = 1;
      
      // Calculate how much extra height the current content needs.
      const extraHeight = this.scrollHeight - minHeight;
      
      // Determine how many additional rows are needed.
      const extraRows = Math.ceil(extraHeight / lineHeight);
      
      // Set the rows: one row plus any extra rows from wrapping.
      this.rows = 1 + extraRows;
    });
  
    // Message input and send button elements
    const sendButton = document.getElementById('send-button');
  
    // Function to update send button visibility
    function updateSendButtonVisibility() {
      const hasContent = messageInput.value.trim().length > 0;
      if (hasContent) {
        sendButton.classList.add('visible');
      } else {
        sendButton.classList.remove('visible');
      }
    }
  
    // Add input event listeners
    messageInput.addEventListener('input', updateSendButtonVisibility);
    messageInput.addEventListener('paste', () => {
      setTimeout(updateSendButtonVisibility, 0);
    });
  
    // Initialize button visibility
    updateSendButtonVisibility();
  
    function copyUrl() {
      const url = new URL(window.location.href);
      url.searchParams.delete('host');
      const shareUrl = url.toString();
      navigator.clipboard.writeText(shareUrl).then(() => {
        const button = document.getElementById('copy-button');
        button.textContent = 'Copied!';
        button.classList.add('copied');
        setTimeout(() => {
          button.textContent = 'Copy';
          button.classList.remove('copied');
        }, 2000);
      }).catch(err => { console.error('Failed to copy:', err); });
    }
  
    socket.on('error', (message) => {
      if (message !== 'Room not found') { alert(message); }
    });
  
    socket.on('disconnect', () => {
      console.log('Disconnected from server');
      // Do not force a reconnect here; let built-in reconnection handle it.
    });
  
    socket.on('reconnect', () => {
      console.log('Reconnected to server');
      if (username) {
        socket.emit('join-room', roomId, isHost, username, userColor);
      }
    });
  
    // Debounce helper to prevent rapid firing
    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    
  
    // Listen for when the page becomes visible (debounced)
    document.addEventListener('visibilitychange', debounce(function() {
      if (!document.hidden) {
        console.log('Page is visible.');
        if (!socket.connected) {
          console.log('Socket not connected; attempting reconnect.');
          socket.connect();
        } else if (username) {
          socket.emit('join-room', roomId, isHost, username, userColor);
        }
      }
    }, 500));
  </script>  


</body>
</html>